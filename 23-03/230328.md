# 완전검색 & 그리디
1. 부분집합
- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는 것
- 바이너리 카운팅을 통한 사전적 순서
  ![binary counting](https://user-images.githubusercontent.com/122499274/228094122-b9b97c00-9e5c-48bc-aec4-a4d88ea8f0ff.png)

2. 조합
- 서로 다른 n개의 원소 중 r개를 순서없이 골라낸 것
  ![combination](https://user-images.githubusercontent.com/122499274/228095001-6cb6c02f-6529-4056-9ca1-ad73f597b2fe.png)
```python
N = 10
for i in range(N-2):
  for j in range(i+1, N-1):
    for k in range(j+1, N):
      print(i, j, k)
```
```python
# n개에서 r개를 고르는 조합(재귀)
def nCr(n, r, s):
  if r==0:
    print(*comb)
  else:
    for i in range(s, n-r+1):
      comb[r-1] = A[i]
      nCr(n, r-1, i+1)

n = 5
r = 3
comb = [0]*r
A = [i for i in range(n)]
nCr(n, r, 0)
```

3. 탐욕 알고리즘
- 규칙을 중간에 바꾸지않는게 원칙 > 이런 특성 때문에 대부분의 탐욕 알고리즘들은 단순하며, 또한 제한적인 문제들에 적용된다
- 최적해를 구하는데 사용되는 근시안적인 방법
- 머리속에 떠오르는 생각을 검증없이 바로 구현하면 greedy 접근이 된다
- 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다
- 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다
- 최적화 문제란 가능한 해들 중에서 가장 좋은 해를 찾는 문제
- 동작 과정
  - 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다
  - 실행 가능성 검사 : 새로운 부분 해 집합이 실행가능한지를 확인(문제의 제약 조건을 위반하지 않는 지 검사)
  - 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인
- Knapsack(배낭 짐싸기)
  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다
  - 부분집합의 총무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택할 수 있다
  - 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가한다
- 탐욕 알고리즘의 필수 요소
  - 탐욕적 선택 속성(탐욕적 선택은 최적해로 갈 수 있음을 보여라)
  - 최적 부분 구조(최적화 문제를 정형화하라)

4. 재귀 복습
```python
def f(i, k):
  if i == k:
    print(*bit)
  else:
    bit[i] = 0
    f(i+1, k)
    bit[i] = 1
    f(i+1, k)

A = [7, 2, 5, 3, 4]
N = len(A)
bit = [0]*N       # A[i] 원소가 부분집합에 포함되는지를 표시함
f(0, N)
```

\+ 푼 문제
- 14005 컨테이너 운반, 13849 배열최소합, 14013 최소 생산 비용, 16898 부분 수열의 합
백트래킹
: 부분 수열의 합, 부분집합의 합, 배열 최소 합, 장훈이의 높은 선반, 최소 생산 비용, 연습문제_베이비진, 수영장, 전기버스2, 전자카트, 격자판의 숫자 이어붙이기, 숫자만들기, 최소합, N-Queen, 요리사, 최대 상금, 동칠이의 일 분배, 디저트카페, 벌꿀채취