# 큐(Queue)
1. 큐의 특성
- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
- 큐의 뒤에서는 삽입만 하고 큐의 앞에서는 삭제만 이루어지는 구조
- 선입선출구조(FIFO)
  - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다
  - 머리: 저장된 원소 중 첫 번째 원소(또는 삭제된 위치)
  - 꼬리: 저장된 원소 중 마지막 원소
- 주요 연산
  - enQueue(item): 큐의 뒤쪽에 원소를 삽입
  - deQueue(): 큐의 앞쪽에서 원소를 삭제하고 반환
  - createQueue(): 공백 상태의 큐를 생성(front=rear=-1)
  - isEmpty: 공백상태인지 확인
  - isFull: 포화상태인지 확인
  - Qpeek(): 큐의 앞쪽에서 원소를 삭제없이 반환

2. 선형큐
- 구현
  - 큐의 크기 = 배열의 크기
  - front 저장된 첫 번째 원소의 인덱스
  - rear 저장된 마지막 원소의 인덱스
  - 초기 상태: front = rear = -1
  - 공백 상태: front == rear
  - 포화상태: rear == n-1
  - 삽입: rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련, 그 인덱스에 해달하는 원소에 item 저장
  - 구현: front 값을 하나 증가시켜 큐에 남아있게 될 첫 번째 원소 이동
- 문제점
  - 잘못된 포화상태 인식: 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고 rear=n-1 상태, 즉 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨

3. 원형큐
- 구조
  - 초기 공백 상태: front = rear = 0
  - 인덱스의 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후, 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야함
    - 이를 위해 나머지 연산자 mod를 사용함
  - front 변수: 공백상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
- 한자리 비어있기 떄문에 원하는 사이즈보다 하나 더 크게 잡아주는 것이 좋다


\+배운 점
사이즈가 크거나 반복횟수가 많아지면 append랑 pop은 매우 느리다
사람이 사용하는 건 중위표기식, 컴퓨터가 사용하는건 후위표기식

