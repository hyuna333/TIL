# 큐의 활용
1. 버퍼
- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
- 버퍼링: 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미한다
- 자료구조
  - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다
  - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용된다

2. BFS
- 그래프를 탐색하는 방법에는 크게 두 가지가 있음
  - 깊이 우선 탐색(DFS)
  - 너비 우선 탐색(BFS)
- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했는 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식(동심원을 거리 순으로 탐색하는 느낌)
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로 선입선출 형태의 자료구조인 큐를 활용함 > 그렇다고 DFS는 스택을 쓰고, BFS는 큐를 써요! 는 아니다
- 초기상태(항상 만들고 시작)
  - visited 배열 초기화
  - Q 생성
  - 시작점 enqueue
- A점부터 시작
  - dequeue A
  - A 방문한 것으로 표시
  - A의 인접점 enqueuue
- 탐색 진행
  - dequeue B
  - B 방문한 것으로 표시
  - B의 인접점 enqueue
- 반복
  - C > D > ...
- 출발점이 여러개일 수도 있다

```python
"""
7 8
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
"""
V, E = map(int, input().split())
arr = list(map(int, input().split()))

# 인접리스트
adjL = [[] for  in range(V+1)]

def bfs(v, N):             # 시작점 v, 마지막 정점 번호 N
    # visited 생성
    vi = [0]*(N+1)
    # 큐 생성
    q = [v]
    # 시작점 인큐 표시
    vi[v] = 1
    while q:
        t = q.pop(0)
        print(t, end=' ')
        # t에 인접이고 방문한 적 없는 v
        for i in adjL[t]:
            if vi[i] == 0:
                q.append(i)             # v 인큐
                vi[i] = vi[t] + 1       # v 인큐표시

for i in range(E):
    n1, n2 = arr[i*2], arr[i*2+1]
    adjL[n1].append(n2)
    adjL[n2].append(n1)

bfs(1)
# 1 2 3 4 5 7 6
```

\+보충수업
- 어떨 때 DFS, BFS를 사용할까?
  - 내가 찾는 정답이 무조건 맨 끝에 있는 것 같다 > DFS
  - 정답이 될 후보가 끝이 아니라 중간에 존재할 수도 있는 경우 > BFS
  - 

\+푼 문제
13955 너비우선탐색, 13956 미로, 13983 노드의 거리, 13959 미로의 거리, 15211 미로1, 14050 contact