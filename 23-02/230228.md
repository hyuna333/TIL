1. 비트연산
- 비트 연산자
  - &: 비트단위로 AND 연산을 한다. 비트검사나 특정비트를 0으로 만들 때 사용한다
  - |: 비트단위로 OR 연산을 한다. 특정비트를 1로 만들 때 사용한다
  - ^: 비트단위로 XOR 연산을 한다. 두 값이 같으면 0, 다르면 1이 나온다
  - ~: 단항 연산자로서 피연산자의 모든 비트를 반전시킨다(~(0011) > (1100))
- 1<<n
  - 2^n의 값을 갖는다
  - 원소가 n개일 경우 모든 부분집합의 수를 의미한다
  - power set(모든 부분 집합)
- i&(1<<j)
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미한다
  - 연산결과가 0이면 j 비트는 0이라는 뜻
- 엔디안
  - 빅 엔디안: 보통 큰 단위가 앞에 옴. 네트워크에 사용. (0x1234 > 12 34)
  - 리틀 엔디안: 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터에서 사용. (0x1234 > 34 12)
  - 확인코드: print(sys.byteorder)

2. 진수
- 10진수 > 타 진수로 변환
   - 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다
- 컴퓨터에서의 음의 정수 표현 방법
  - 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환한다
  - 2의 보수: 1의 보수방법으로 표현된 값의 최하위비트에 1을 더한다

3. 실수
- 실수의 표현
  - 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다
  - 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다
    - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
- 연습문제1
```python
# 0000000111100000011000000111100110000110000111100111100111111001100111
arr = list(map(int, input()))
N = len(arr)
num = 0

for i in range(N):
    j = i%7
    num += arr[i] * (2**(6-j))
    if j == 6:
        print(num, end=' ')
        num = 0
```

- 연습문제2
```python
# 01D06079861D79F99F
arr = input()
for x in arr:
    num = int(x, 16)
    for j in range(3, -1, -1):
        bit = 1 if num&(1<<j) else 0
        print(bit, end='')
    print()
```


\+ 푼 문제
- 14123 이진수의 십진수 출력, 14124 십육진수의 십진수 출력, 14125 암호 출력