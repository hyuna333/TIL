# 스택2
1. 재귀호출
- 자기 자신을 호출하여 순환 수행되는 것
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성
- 피보나치
  - 0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치라 한다
  - F0 = 0, F1 = 1
  - Fi = Fi-1 + Fi-2 for i >= 2
  - 위의 정의로부터 파보나치 수열의 i번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다
  - 엄청난 중복 호출이 존재한다
- memoization
  - 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다
  - 동적 계획법의 핵심이 되는 기술이다
- 파이썬에서 재귀호출은 약 1000반 미만으로 부를 수 있다

2. 동적 계획
- Dynamic Programming 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다
- 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다
- 피보나치 수 DP 적용
  - 피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어져 있다
  ```python
  def fibo2(n):
    f = [0]*(n+1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n+1):
      f[i] = f[i-1] + f[i-2]

    return f[n]
  ```
- DP의 구현 방식
  - memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다
  - 재귀적 구조는 내부에 시스템 호출 스택(ex)함수 호출 복귀에 시간이 걸리는 문제)을 사용하는 오버헤드가 발생하기 때문이다

- 재귀 예시
  ```python 
  def f(i, k):      # i=단계, k=목표
  if i == k:        # 목표도달하면 리턴
    print(B)
    return 
  else:
    B[i] = A[i]     # i번 원소를 복사하는 재귀함수
    f(i+1, k)       # 아니라면 다음 단계

  A = [10, 20, 30]
  B = [0] * 3
  ```


3. DFS(깊이우선탐색)
- 비선형구조(서로 얽혀 복잡한 상태의 구조)인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함
- 깊이 우선 탐색(Depth First Search)
  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가(내가 정한 규칙대로 우선 간다) 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
  - 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용
  - 순서  
  1) 시작 정점 v(=node)를 결정하여 방문한다  
  2) 정점 v에 인접한(현재 정점에서 이동가능한 정점, 간선 혹은 edge로 이어진 정점) 정점 중에서  
    1: 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시 2)를 반복한다.  
    2: 방분하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다.  
  3) 스택이 공백이 될 때까지 2)를 반복한다
  ![image](https://user-images.githubusercontent.com/122499274/218615515-000a2acf-7ebf-4db9-9818-35e12f35aad5.png)
  ```python
  # 인풋
  # 7 8
  # 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7
  V, E = map(int, input().split())
  arr = list(map(int, input().split()))
  adjM = [[0]*(V+1) for _ in range(V+1)]
  adjL = [[] for _ in range(V+1)]
  
  for i in range(E):
    v1, v2 = arr[i*2], arr[i*2+1]
    # 인접행렬
    adjM[v1][v2] = 1
    adjM[v2][v1] = 1    # 서로 연결되어 있다

    # 인접리스트
    adjL[v1].append(v2)
    adjL[v2].append(v1)
  ```
- 너비 우선 탐색(Breadth First Search)

