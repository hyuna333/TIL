# 객체 지향 프로그래밍
- 객체 지향 프로그래밍이란?  
  : 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 '객체'들의 모임으로 파악하고자 하는 것이다.  
  프로그램을 여러 개의 독립된 객체들과 그 객체 간의 상호작용으로 파악하는 프로그래밍 방법
- 하나의 객체 안에는 data가 존재하고 이 data를 활용할 수 있는 메서드들이 존재
- 기본 문법
  - 클래스 정의 class Myclass:
  - 인스턴스 생성 instance = Myclass()
  - 메서드 호출 instance.my_method()
  - 속성 접근 instance.my_attribute
- 클래스와 인스턴스
  - 클래스 : 객체들의 분류/설계도
  - 인스턴스 : 하나하나의 실체
- 객체 비교하기
  - == : 동등한(equal), 변수가 참조하는 객체가 동등한 경우 True(내용이 동일), 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님
  - is : 동일한(identical), 두 변수가 동일한 객체를 가리키는 경우 True

# 재귀함수
- 재귀함수에서 변하는 것은 argument 뿐
- 필요한 것
  - 멈추는 조건
  - 조건을 맞추기 위해서 args가 바뀌어야한다
- while에서는 멈추려면 break를 사용하지만 함수에서는 return을 사용한다
- 재귀함수를 어디에 썼을 때 가장 효과적일까 > 반복(나랑 연관지어서 반복)
- 직전의 상태를 가지고 현재의 상태를 쉽게 구할 수 있다


1. 객체 지향 프로그래밍
- 절차 지향 프로그래밍  
  : 프로그램 전체가 유기적인 흐름으로 연결, 기능 중심의 프로그램, 순서가 정해져있으므로 실행이 빠름  
  \> 단점으로는 중간에 오류가 나면 고치기가 힘들다  
  하드웨어가 발전함에 따라 소프트웨어도 점점 커지고 복잡한 설계가 요구됨  
  하드웨어의 발전 속도를 소프트웨어의 발전 속도가 따라가지 못함 > 소프트웨어 위기
- 객체 지향 프로그래밍이란?  
  : 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 '객체'들의 모임으로 파악하고자 하는 것이다.  
  프로그램을 여러 개의 독립된 객체들과 그 객체 간의 상호작용으로 파악하는 프로그래밍 방법
- 하나의 객체 안에는 data가 존재하고 이 data를 활용할 수 있는 메서드들이 존재
- 장점
  - 객체를 잘 만들어놓으면 계속해서 재사용이 가능하다
  - 객체는 그 자체로 데이터와 행동이 정의됨(독립적) > 내부구조를 몰라도 다른 객체와 조립하면서 개발이 가능
  - 객체 단위로 모듈화시켜 개발할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발 가능
  - 개발 용이성, 유지 보수 편의성, 신뢰성을 바탕으로 생산성이 대폭 증가
- 단점
  - 설계 시 많은 노력과 시간이 필요함 > 다양한 객체들의 상호 작용 구조를 만들기 위해 많은 시간과 노력이 필요
  - 실행 속도가 절차 지향보다 느리다


2. OOP 기초
- 객체 : 클래스에서 정의한 것을 토대로 메모리에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미하며, 변수, 자료 구조, 함수 또는 메서드가 될 수 있다
- 클래스라는 설계도로 여러가지 객체를 찍어낸다
- 클래스로 만든 객체를 인스턴스라고도 함(클래스로 인스턴스를 만드는거구나~ 까지만 일단 이해)
- 파이썬은 모든 것이 객체(객체 안에는 data와 행동이 존재한다)
- 나만의 무언가를 만들고 싶다면 나만의 class를 만들면된다
- 함수는 기능만 하고 끝나지만 class는 데이터와 함수를 묶을 수 있다
- 객체의 특징
  - 타입 : 어떤 연산자와 조작이 가능한가?
  - 속성 : 어떤 상태를 가지는가?
  - 조작법 : 어떤 행위를 할 수 있는가?
- class와 instance


3. OOP 문법
- class를 정의한다 == 나만의 타입을 만드는 것
- 기본 문법
  - 클래스 정의 class Myclass:
  - 인스턴스 생성 instance = Myclass()
  - 메서드 호출 instance.my_method()
  - 속성 접근 instance.my_attribute
- 클래스와 인스턴스
  - 클래스 : 객체들의 분류/설계도
  - 인스턴스 : 하나하나의 실체
  - isinstance(a, b) > a가 b의 instance니?
- 객체 비교하기
  - == : 동등한(equal), 변수가 참조하는 객체가 동등한 경우 True(내용이 동일), 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님
  - is : 동일한(identical), 두 변수가 동일한 객체를 가리키는 경우 True
- 속성
  - 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미
  - 클래스 변수/인스턴스 변수가 존재
  - 변수/공간 
- 인스턴스와 클래스 간의 이름 공간(namespace)
  - 클래스를 정의하면 클래스와 해당하는 니 이름 공간 생성
  - 인스턴스를 만들면, 인스턴스 객체가 생성되고 이름 공간 생성
  - 인스턴스에서 특정 속성에 접근하면, 인스턴스-클래스 순으로 탐색
- 인스턴스 변수
  - 인스턴스가 개인적으로 가지고 있는 속성으로, 각 인스턴스들의 고유한 변수
  - \<instace>.\<name>으로 접근 및 할당
- 클래스 변수
  - 클래스 선언 내부에서 정의
  - \<classname>.\<name> 으로 접근 및 할당
- self
  - 인스턴스 자기자신
  - 파이썬에서 인스턴스 메서드는 호출 시 첫번째 인자로 인스턴스 자신이 전달되게 설계
- OOP 메서드
  - 클래스, 인스턴스 메서드의 가장 큰 차이점 > 정의 위치가 다르다, 인스턴스는 인스턴스 메서드, 클래스 메서드 둘다 사용 가능하지만 클래스는 인스턴스 메서드 사용 불가능
  - 메서드 : 특정 데이터 타입/클래스의 객체에 공통적으로 적용 가능한 행위(함수)
- 인스턴스 메서드(우리가 대부분 사용하는 메서드)
  - 인스턴스 변수를 사용하거나, 인스턴스 변수에 값을 설정하는 메서드
  - 클래스 내우벵 정의되는 메서드의 기본
  - 호출 시, 첫번째 인자로 인스턴스 자기자신(self)이 자동으로 전달됨
- 매직 메서드(특별한 인스턴스 메서드)
  - Double underscore(__)가 있는 메서드는 특수한 동작을 위해 만들어진 메서드로, 스페셜 메서드 혹은 매직 메서드라고 불림
  - 특정 상황에 자동으로 불리는 메서드
  - 예시 : 객체의 특수 조작 행위를 지정(함수, 연산자 등)
  - \__str__ : 이 객체를 문자열로 표현하면 어떻게 표현할지를 지정
  - \__gt__ : 부등호 연산자(>, greater than
  - len, lt, le, eq, gt, ge, ne(외울 필요 x)
- 생성자 메서드
  - 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
  - 인스턴스 변수들의 초기값을 설정
- 클래스 메서드
  - 인스턴스와 상관없이 클래스 단위에서 사용하는 메서드
  - 호출 시 첫번째 인자로 클래스가 전달됨
  - @classmethod 데코레이터를 사용하여 정의

 
### +오후 실습
추상화
- 중요하다고 생각한 부분만 뽑아서 표현 > 사람마다 디테일은 다르지만 중요하다고 생각하는 부분은 같다 > 공통점을 뽑아내는 행동이다

staticmethod
- class와 전혀 상관없는 애들을 불러올 수 있다.

class 연습
```python
class Pig:
    belly_price = 1000 # 클래스 변수

    def __init__(self, stock):
        self.stock = stock


    # 주문이 들어왔을 때의 가격 -> 메서드
    def order_price(self, amount):
        if self.stock >= amount:
            return self.belly_price * amount

        else:
            return "재고가 없어요."
            # return f"재고가 {self.stock}만큼 있습니다"
        

    def order(self, amount, money):
        price = self.order_price(amount)
        if price <= money:
            self.stock = self.stock - amount
            change = money - price
            return change
        else: 
            return '못삼'


    def prices(self, amount, percent):
        self_sale = self.belly_price * (1 - percent)
        # return b_pig.belly_price * amount, round(b_sale * amount)
        return "원래 가격: {}, 할인된 가격: {}".format(self.belly_price * amount, round(self_sale * amount))
    
    # def original_price(self):
    #     return Pig.belly_price

    @classmethod
    def original_price(cls):
        return cls.belly_price
    # 위와 아래가 동일한 함수이지만 교수님이었으면 아래 함수를 이용했을 것이다.

a_pig = Pig(100)
b_pig = Pig(150)


# b 돼지의 가격이 20% 할인됨
# b 돼지에서 원래 가격도 접근 가능함
# b 돼지를 50만큼 샀을 때, 원래 가격, 할인된 가격 둘다 반환.
# Pig.belly_price도 가능하지만 b 돼지에서 접근하고 싶기 때문에 다른 것 사용 > def original_price


print(b_pig.prices(50, 0.2))

"""
1. 동작여부
2. 재사용이 가능한지, 읽기 쉬운지
3. 비효율적이지는 않을지

동작여부와 읽기 쉬운지 정도는 지금도 고려해보는게 좋음
나머지 두개는 좀 더 파이썬에 익숙해진 후에 고려해도 좋음

무엇을 하고 싶은가 > 메서드
어떤 > 변수
"""
```