1. 함수 응용
- map(function, iterable) : 반복가능한 애들(iterable)을 넘겨주면 하나하나마다 function을 적용한 애들을 넘겨준다
  map(int, input().split()) > input 애들을 다 int 처리해줌
  [map 예시](1.py)
- filter(function, iterable) : True만 통과가능, 순회 가능한 데이터구조(iterable)의 모든 요소에 function 적용하고, 그 결과가 True인 것들을 filter object로 반환
- zip(*iterables) : **복수**의 iterable을 모아 튜플을 원소로 하는 zip object를 반환
  [zip 예시](2.py)
- lambda[parameter]
  - 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명 함수라고도 불림
  - return문을 가질 수 없음
  - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
  - 간단한 일을 하거나, 딱 한 번만 쓰고 싶은 함수를 만들 때 사용
  - [lambda 예시](1.py)
- 재귀함수(reculsive)
  - 자기자신을 호출하는 함수
  - for, while보다 명시적으로 logic을 설명할 수 있다
  - 재귀의 형태이면 한 번은 그림을 그려보자
  - 반드시 basecase(종료되는 상황)를 넣어줘야한다
  - 반복문과 재귀함수 비교
    - 두 개 왔다갔다 가능
    - 재귀 호출은 변수 사용을 줄여줄 수 있음
  - [재귀 예시](2.py)


2. 패킹/언패킹
- 패킹/언패킹 연산자 \*
- 모든 시퀀스형(리스트, 튜플 등)은 패킹/언패킹 연산자를 활용하여 객체의 패킹 또는 언패킹이 가능
  ```python
  x, y = 1, 2
  z = 1, 2, 3
  print(z)  > (1, 2, 3)

  a, b = 1, 2, 3, 4   > error too many values to unpack
  a, *b = 1, 2, 3, 4   
  # a에 1개 넣고 남은거 다 b에 넣어

  def my_sum(a, b, c):
    return a + b + c
  
  num_list = [10, 20, 30]

  rlt = my_sum(num_list[0], num_list[1], num_list[2])
  rlt = my_sum(*num_list)
  # num_list가 언패킹되어서 각각 들어간다
  ```
  ```python
  def test(*values):
    for value in values:
      print(value)

  test(1)
  test(1, 2)
  test(1, 2, 3, 4)
  # 가변인자를 사용할 수 있다.
  ```
  ```python
  def my_sum(*agrs):
    rlt = 0
    for value in args:
      rlt += value
    return rlt
  my_sum()  # 0
  my_sum(1, 2, 3) # 6
  ```
  ```python
  def test(**kwargs):
    print(kwargs)
    return kwargs

  test(name= 'aiden', age = 21)
  # {'name': 'aiden', 'age': 21}
  ```
- 패킹
  - 대입문의 좌변 변수에 위치
  - 우변의 객체 수가 좌변의 변수 수보다 많을 경우 객체를 순서대로 대입
  - 나머지 항목들은 모두 별 기호 표시된 변수에 리스트로 대입
- 언패킹
  - argument 이름이 *로 시작하는 경우 argument unpacking이라 함
  - *패킹의 경우, 리스트로 대입
  - *언패킹의 경우 튜플 형태로 대입
- 가변인자(*args)
  - 여러 개의 positional argument를 하나의 필수 parameter로 받아서 사용
  - 몇 개의 positional argument를 받을지 모르는 함수를 정의할 떄 유용
- 가변 키워드 인자(**kwargs)
  - 몇 개의 키워드 인자를 받을지 모르는 함수를 정의할 때 유용
  - **kwargs는 딕셔너리로 묶여 처리되며, parameter에 **를 붙여 표현


3. 모듈
- .py 파일 하나를 말한다
- 모듈과 패키지
  - 자주 쓰는 기능들 > 함수로 만든다
  - 다양한 기능(함수)을 하나의 파일로 묶어둔 것 > 모듈 단위로 다른 곳에서 재사용 가능 (파일단위)
  - 다양한 파일을 하나의 폴더로 만든 것이 패키지(package) > .py를 묶어서 폴더로 만든 게 패키지 (폴더단위)
  - 패키지를 묶어서 만든 것이 라이브러리 (폴더단위)
  - 파이썬에서는 패키지와 라이브러리의 경계가 모호
  - 이 것을 관리하는 관리자 pip
  - 패키지의 활용 공간을 가상환경으로 나눠볼 수 있다
  - 모듈 : 특정 기능을 하는 코드를 파이썬 파일(.py) 단위로 작성한 것
  - 패키지 : 특정 기능과 관련된 여러 모듈의 집합, 패키지 안에는 또 다른 서브 패키지를 포함
  - from module import * 여기서 *은 all을 뜻한다 > module 안에 있는거 다 꺼내와
- 파이썬 라이브러리
  - pip : PyPI에 저장된 외부 패키지들을 설치하도록 도와주는 패키지 관리 시스템
  - 패키지 설치 
    - 최신 버전/ 특정 버전/ 최소 버전을 명시하여 설치할 수 있음
    - 이미 설치되어 있는 경우 이미 설치되어 있음을 알리고 아무것도 하지 않음
  - 패키지 관리하기
    - 아래의 명령어들을 통해 패키지 목록을 관리[1]하고 설치할 수 있음[2]
    - 일반적으로 패키지를 기록하는 파일의 이름은 requirements.txt로 정의함
    - pip freeze > requirements.txt
    - pip install -r requirements.txt
  - 모듈과 패키지 활용하기
    - 패키지 만들기
      - __init_.py > 이 파일이 있으면 파이썬이 그 파일이 존재하는 폴더를 패키지로 인식한다

