1. 서로소 집합
- 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들이다. 다시 말해 교집합이 없다
- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자라 한다.
- 상호배타집합을 표현하는 방법
  - 연결 리스트, 트리
- 상호배타집합 연산
  - Make-Set(x) > x를 대표로하는 집합 만들기
  - Find-Set(x) > x가 속한 집합의 대표원소를 알려줘
  - Union(x, y) > x와 y가 속한 집합을 합쳐서 새로운 집합 만들기
- 트리
  - 하나의 집합을 하나의 트리로 표현한다
  - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다
  - 대표원소는 자기 자신을 가리킨다 
```python
def find_set(x):
    # 대표 찾을때까지 반복
    while x != rep[x]:
        x = rep[x]
    return x

def union(x, y):
    # y의 대표원소가 x의 대표원소를 가리키도록 만드는 것
    rep[find_set(y)] = find_set(x)


rep = [i for i in range(6)]
```


2. 최소 신장 트리(MST)
- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

3. Prim 알고리즘
- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  - 임의 정점을 하나 선택해서 시작
  - 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  - 모든 정점이 선택될 때까지 과정 반복

4. KRUSKAL 알고리즘
- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  - 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴(사이클이 존재하면 다음으로 가중치가 낮은 간선 선택)
  - n-1개의 간선이 선택될 때까지 반복

5. 최단경로
- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로(모든 정점을 거치는 것이 아니다)
- 다익스트라(dijksstra)
  - 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
```python 
def dijkstra(s, V):
    # 최소 비용이 결정된 정점 집합 U
    U = [0]*(V+1)
    U[s] = 1
    for i in range(V+1):
        D[i] = adjM[s][i]

    # 남은 정점의 비용 결정
    for _ in range(V):
        mn, i_mn = INF, 0
        for i in range(V+1):
            if U[i] == 0 and mn > D[i]:
                mn, i_mn = D[i], i
        U[i_mn] = 1

    for j in range(V+1):
        if 0<adjM[w][v]<INF:        # 인접
            D[v] = min(D[v], D[w]+adjM[w][v])


INF = 100000
V, E = map(int, input().split())
adjM = [[INF]*(V+1) for _ in range(V+1)]

for i in range(V+1):
    adjM[i][i] = 0

for _ in range(E):
    u, v, w = map(int, input().split())
    adjM[u][v] = w

D = [0]*(V+1)
dijkstra(0, V)
```

\+ 푼 문제
- 14252 최단 경로, 14290 최소 신장 트리